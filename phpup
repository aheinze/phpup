#!/usr/bin/env bash
set -euo pipefail

# phpup: Start FrankenPHP with advanced configuration options
# - Auto-discovers a free port
# - Uses a custom Caddyfile if present (supports env placeholders)
# - If none is found, generates an optimized Caddyfile in .phpup/
# - Supports worker mode, file watching, HTTPS, and performance tuning
#
# Usage:
#   ./phpup [options]
#
# Notes for custom Caddyfiles:
#   You can reference these env vars in your Caddyfile: {\$HOST}, {\$PORT}, {\$DOCROOT}
#   The script exports them before starting FrankenPHP.


HOST="127.0.0.1"
START_PORT="${PORT:-8000}"
CADDYFILE=""
DOCROOT=""
DOMAIN=""
AUTO_DOMAIN=0
SAVE_MODE=0
MANAGE_HOSTS=1
HOSTS_ENTRY_ADDED=0
DRY_RUN=0
STOP_MODE=0
QUIET=0
MODE=""
WORKER_MODE=0
WATCH_MODE=0
WATCH_PATTERNS=""
PHP_THREADS="auto"
MAX_WAIT_TIME="30s"
HTTPS_MODE="off"
VERBOSE=0
COMPRESSION=1
OPEN_BROWSER=0
XDEBUG=0
ENV_FILE=""
EXTRA_ARGS=()
INIT_MODE=0
INSTALL_MODE=0
BUILD_PHP_MODE=0
LIST_MODE=0
STATS_MODE=0
FORCE_MODE=0

# Configuration file path
CONFIG_FILE=".phpup/config"

log() {
  if [ "$QUIET" -ne 1 ]; then
    # Only add timestamp if this is a long-running operation or verbose mode
    if [ "$VERBOSE" -eq 1 ] || [[ "$*" =~ (Starting|Stopping|Executing|started|stopped) ]]; then
      echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
    else
      echo "$*" >&2
    fi
  fi
}

err() {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $*" >&2
}

debug() {
  if [ "$VERBOSE" -eq 1 ]; then
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] DEBUG: $*" >&2
  fi
}

# Resource monitoring and limits
check_system_resources() {
  local warnings=0

  # Check available memory (warn if less than 100MB)
  if command_exists free; then
    available_mb=$(free -m | awk '/^Mem:/ { print $7 }' 2>/dev/null || echo 1000)
    if [ "$available_mb" -lt 100 ] 2>/dev/null; then
      log "‚ö†Ô∏è  Warning: Low available memory (${available_mb}MB)"
      warnings=$((warnings + 1))
    fi
  fi

  # Check disk space in current directory (warn if less than 100MB)
  if command_exists df; then
    available_mb=$(df -BM . | awk 'NR==2 { gsub(/M/, "", $4); print $4 }' 2>/dev/null || echo 1000)
    if [ "$available_mb" -lt 100 ] 2>/dev/null; then
      log "‚ö†Ô∏è  Warning: Low disk space (${available_mb}MB)"
      warnings=$((warnings + 1))
    fi
  fi

  return $warnings
}

# Open browser with the given URL
open_browser() {
  local url="$1"

  if [ -z "$url" ]; then
    debug "open_browser: No URL provided"
    return 1
  fi

  debug "Attempting to open browser with URL: $url"

  # Try different methods to open browser based on the platform
  if command_exists xdg-open; then
    # Linux
    xdg-open "$url" >/dev/null 2>&1 &
  elif command_exists open; then
    # macOS
    open "$url" >/dev/null 2>&1 &
  elif command_exists start; then
    # Windows (Git Bash, WSL)
    start "$url" >/dev/null 2>&1 &
  elif [ -n "$BROWSER" ]; then
    # Use BROWSER environment variable
    "$BROWSER" "$url" >/dev/null 2>&1 &
  elif command_exists firefox; then
    firefox "$url" >/dev/null 2>&1 &
  elif command_exists google-chrome; then
    google-chrome "$url" >/dev/null 2>&1 &
  elif command_exists chromium; then
    chromium "$url" >/dev/null 2>&1 &
  else
    log "‚ö†Ô∏è  Could not detect browser command to open $url"
    log "   You can set the BROWSER environment variable or install xdg-open"
    return 1
  fi

  log "üåê Opening browser: $url"
  return 0
}

usage() {
  cat <<EOF
Usage: phpup [options]

Basic Options:
  --host HOST           Host to bind (default: 127.0.0.1)
  --port PORT           Port to use (default: 8000 or \$PORT env)
  --caddyfile FILE      Path to custom Caddyfile (default: auto-detect)
  --docroot DIR         Document root (default: ./public, ./web, or .)

PHP Configuration:
  --php-threads NUM     Number of PHP threads (default: auto, can be number)
  --max-wait TIME       Max time to wait for free thread (default: 30s)

Advanced Features:
  --worker              Enable worker mode (experimental)
  --watch               Enable file watcher for auto-reload
  --watch-pattern PAT   Additional watch patterns (can use multiple times)
  --https MODE          HTTPS mode: off|local|on (default: off)
  --compression         Enable HTTP compression (default: on)
  --no-compression      Disable HTTP compression
  --open, -o            Open browser automatically after server starts
  --no-open             Do not open browser (override config)

Domain & Configuration:
  --domain DOMAIN       Custom local domain (e.g., myapp.test)
  --auto-domain         Auto-detect domain from folder name
  --no-hosts            Skip /etc/hosts management
  --save                Save current settings to .phpup/config

Development & Debug:
  --xdebug              Enable Xdebug step debugger (port 9003)
  --verbose, -v         Verbose output and show FrankenPHP debug output
  --env-file FILE       Load environment variables from file
                        (also auto-loads .phpup/.env if it exists)

Other Options:
  --init                Generate .phpup/ config files and exit
                        (creates Caddyfiles, php.ini, configures error/access logs)
  --force               Overwrite existing config files (use with --init)
  --install             Install phpup to /usr/local/bin/ for system-wide use
  --build-php           Interactive helper to build custom FrankenPHP with additional extensions
  --stop                Stop all running FrankenPHP processes and exit
  --list                List running FrankenPHP instances for current user
  --stats               Show detailed statistics (uptime, memory, threads) for running processes
  --dry-run             Print the computed command and exit
  --quiet               Reduce output
  -h, --help            Show this help
  --                    Pass remaining args to FrankenPHP

Environment variables available to Caddyfile:
  HOST, PORT, DOCROOT, SERVER_NAME, SERVER_ROOT, PHP_THREADS, MAX_WAIT_TIME, WORKER_FILE, PHPUP_DIR

  Generated Caddyfiles use these variables (e.g., {\$HOST}:{\$PORT}) so you can
  override them with command-line options even after generation.

Examples:
  # Initialize configuration files for customization
  ./phpup --init

  # Install phpup system-wide
  sudo ./phpup --install

  # Build custom FrankenPHP with Xdebug
  ./phpup --build-php

  # Stop all running FrankenPHP processes
  ./phpup --stop

  # Basic usage
  ./phpup

  # Auto-open browser after starting
  ./phpup --open

  # Development with file watching
  ./phpup --watch --verbose

  # Show FrankenPHP debug logs
  ./phpup --verbose

  # HTTPS with custom port and threads
  ./phpup --https local --port 8443 --php-threads 10

  # Worker mode
  ./phpup --worker
EOF
}

command_exists() { command -v "$1" >/dev/null 2>&1; }

# Cross-platform stat helpers (Linux uses -c, macOS uses -f)
get_file_perms() {
  local file="$1"
  if stat -c %a "$file" 2>/dev/null; then
    return
  fi
  stat -f %Lp "$file" 2>/dev/null || echo "unknown"
}

get_file_owner_uid() {
  local file="$1"
  if stat -c %u "$file" 2>/dev/null; then
    return
  fi
  stat -f %u "$file" 2>/dev/null || echo "0"
}

# Production hardening checks
security_checks() {
  local warnings=0

  # Check if running as root (security risk)
  if [ "$(id -u)" = "0" ]; then
    err "Security Warning: Running as root is not recommended for development servers"
    warnings=$((warnings + 1))
  fi

  # Check for sensitive files in docroot
  if [ -n "$DOCROOT" ] && [ -d "$DOCROOT" ]; then
    for sensitive_file in ".env" ".git" "config.php" "wp-config.php" ".htaccess" ".htpasswd"; do
      if [ -f "$DOCROOT/$sensitive_file" ]; then
        log "‚ö†Ô∏è  Security Warning: Sensitive file found in docroot: $sensitive_file"
        warnings=$((warnings + 1))
      fi
    done
  fi

  # Check for weak file permissions
  if [ -f ".phpup/.env" ]; then
    env_perms=$(get_file_perms ".phpup/.env")
    if [ "$env_perms" != "600" ] && [ "$env_perms" != "unknown" ]; then
      log "‚ö†Ô∏è  Security Warning: .env file has permissive permissions ($env_perms), should be 600"
      warnings=$((warnings + 1))
    fi
  fi

  return $warnings
}

# Set secure file permissions
secure_files() {
  # Secure .env file if it exists
  if [ -f ".phpup/.env" ]; then
    chmod 600 ".phpup/.env" 2>/dev/null || true
  fi

  # Secure configuration directory
  if [ -d ".phpup" ]; then
    chmod 700 ".phpup" 2>/dev/null || true
  fi

  # Secure config file
  if [ -f "$CONFIG_FILE" ]; then
    chmod 600 "$CONFIG_FILE" 2>/dev/null || true
  fi
}

# Load configuration from .phpup/config
load_config() {
  if [ ! -f "$CONFIG_FILE" ]; then
    return 0
  fi

  debug "Loading configuration from $CONFIG_FILE"

  while IFS='=' read -r key value || [ -n "$key" ]; do
    # Skip empty lines and comments
    case "$key" in
      ''|'#'*) continue ;;
    esac

    # Remove leading/trailing whitespace
    key=$(echo "$key" | xargs 2>/dev/null || echo "$key")
    value=$(echo "$value" | xargs 2>/dev/null || echo "$value")

    # Only set if not already set by command-line args
    case "$key" in
      HOST)
        [ "$HOST" = "127.0.0.1" ] && HOST="$value"
        debug "Loaded HOST=$value from config"
        ;;
      PORT)
        [ "$START_PORT" = "8000" ] && START_PORT="$value"
        debug "Loaded PORT=$value from config"
        ;;
      DOMAIN)
        [ -z "$DOMAIN" ] && DOMAIN="$value"
        debug "Loaded DOMAIN=$value from config"
        ;;
      HTTPS_MODE)
        [ "$HTTPS_MODE" = "off" ] && HTTPS_MODE="$value"
        ;;
      WORKER_MODE)
        [ "$WORKER_MODE" -eq 0 ] && WORKER_MODE="$value"
        ;;
      WATCH_MODE)
        [ "$WATCH_MODE" -eq 0 ] && WATCH_MODE="$value"
        ;;
      COMPRESSION)
        [ "$COMPRESSION" -eq 1 ] && COMPRESSION="$value"
        ;;
      PHP_THREADS)
        [ "$PHP_THREADS" = "auto" ] && PHP_THREADS="$value"
        ;;
      DOCROOT)
        [ -z "$DOCROOT" ] && DOCROOT="$value"
        ;;
      OPEN_BROWSER)
        [ "$OPEN_BROWSER" -eq 0 ] && OPEN_BROWSER="$value"
        ;;
      XDEBUG)
        [ "$XDEBUG" -eq 0 ] && XDEBUG="$value"
        ;;
    esac
  done < "$CONFIG_FILE"
}

# Save configuration to .phpup/config
save_config() {
  mkdir -p .phpup

  log "üíæ Saving configuration to $CONFIG_FILE"

  cat > "$CONFIG_FILE" <<EOF
# phpup configuration
# This file is auto-generated. Edit manually if needed.
# Command-line flags override these settings.

DOMAIN=$DOMAIN
HTTPS_MODE=$HTTPS_MODE
WORKER_MODE=$WORKER_MODE
WATCH_MODE=$WATCH_MODE
COMPRESSION=$COMPRESSION
PHP_THREADS=$PHP_THREADS
DOCROOT=$DOCROOT
OPEN_BROWSER=$OPEN_BROWSER
XDEBUG=$XDEBUG
EOF

  chmod 600 "$CONFIG_FILE"
  log "‚úÖ Configuration saved"
}

# Auto-detect domain from folder name
infer_domain() {
  local folder_name
  folder_name=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
  echo "${folder_name}.test"
}

# Sanitize and validate domain name
sanitize_domain() {
  local domain="$1"
  # Lowercase first, then remove any dangerous characters - only allow alphanumeric, dash, and dot
  echo "$domain" | tr '[:upper:]' '[:lower:]' | tr -cd 'a-z0-9.-'
}

# Validate domain name
validate_domain() {
  local domain="$1"

  # Block any potentially dangerous characters (extra safety check)
  if [[ "$domain" =~ [\*\;\$\`\{\}\|\<\>\"\'] ]]; then
    return 1
  fi

  # Allow .test, .local, .localhost TLDs and standard domain format
  if [[ "$domain" =~ ^[a-z0-9][a-z0-9\.-]*[a-z0-9]\.(test|local|localhost)$ ]] || \
     [[ "$domain" =~ ^[a-z0-9][a-z0-9\.-]*\.[a-z]{2,}$ ]]; then
    return 0
  fi
  return 1
}

# Check if mkcert is available and set up
check_mkcert() {
  if command_exists mkcert; then
    # Check if CA is installed
    if mkcert -CAROOT >/dev/null 2>&1; then
      return 0
    fi
  fi
  return 1
}

# Setup mkcert for local SSL
setup_mkcert() {
  log "üîê Setting up local SSL with mkcert..."

  if ! command_exists mkcert; then
    log "üì• mkcert not found. Installing..."

    # Platform-specific installation
    if command_exists brew; then
      brew install mkcert nss
    elif command_exists apt-get; then
      log "   Please install mkcert manually:"
      log "   https://github.com/FiloSottile/mkcert#installation"
      return 1
    else
      log "‚ö†Ô∏è  Could not auto-install mkcert"
      log "   Please install manually: https://github.com/FiloSottile/mkcert"
      return 1
    fi
  fi

  # Install local CA if not already installed
  if ! mkcert -CAROOT >/dev/null 2>&1 || [ ! -d "$(mkcert -CAROOT)" ]; then
    log "üîß Installing local Certificate Authority..."
    mkcert -install
  fi

  return 0
}

# Generate SSL certificate for domain
generate_cert() {
  local domain="$1"

  if [ -z "$domain" ]; then
    return 1
  fi

  mkdir -p .phpup/certs

  if [ -f ".phpup/certs/${domain}.pem" ] && [ -f ".phpup/certs/${domain}-key.pem" ]; then
    debug "SSL certificate for $domain already exists"
    return 0
  fi

  log "üìú Generating SSL certificate for $domain..."

  # Use subshell to avoid changing working directory of the main script
  (
    cd .phpup/certs || exit 1
    mkcert "$domain" "*.${domain}" >/dev/null 2>&1

    # mkcert creates files with specific names, rename them for consistency
    if [ -f "${domain}+1.pem" ]; then
      mv "${domain}+1.pem" "${domain}.pem"
      mv "${domain}+1-key.pem" "${domain}-key.pem"
    fi
  )

  if [ -f ".phpup/certs/${domain}.pem" ]; then
    log "‚úÖ SSL certificate generated for $domain"
    return 0
  fi

  return 1
}

# Manage /etc/hosts entry for domain
manage_hosts_entry() {
  local action="$1"  # add or remove
  local domain="$2"
  local ip="${3:-127.0.0.1}"

  local hosts_file="/etc/hosts"
  local marker="# phpup-managed"

  # Check if we need sudo
  if [ ! -w "$hosts_file" ]; then
    if ! command_exists sudo; then
      log "‚ö†Ô∏è  Cannot modify $hosts_file (no sudo available)"
      return 1
    fi
  fi

  if [ "$action" = "add" ]; then
    # Check if entry already exists (use -F for literal string matching)
    if grep -Fq "$ip $domain" "$hosts_file" 2>/dev/null; then
      debug "Domain $domain already in $hosts_file"
      return 0
    fi

    log "üåç Adding $domain to $hosts_file"
    log "   This requires sudo permission..."

    # Add entry with marker
    if [ -w "$hosts_file" ]; then
      echo "$ip $domain $marker" >> "$hosts_file"
    else
      echo "$ip $domain $marker" | sudo tee -a "$hosts_file" >/dev/null
    fi

    log "‚úÖ Added $domain ‚Üí $ip to hosts file"

  elif [ "$action" = "remove" ]; then
    if grep -Fq "$domain $marker" "$hosts_file" 2>/dev/null; then
      log "üóëÔ∏è  Removing $domain from $hosts_file"

      # Escape dots in domain for safe use in sed regex
      local escaped_domain="${domain//./\\.}"
      if [ -w "$hosts_file" ]; then
        sed -i.backup "/${escaped_domain}.*${marker}/d" "$hosts_file"
      else
        sudo sed -i.backup "/${escaped_domain}.*${marker}/d" "$hosts_file"
      fi

      log "‚úÖ Removed $domain from hosts file"
    fi
  fi

  return 0
}

is_port_free() {
  # Returns 0 if free, 1 if taken
  local host="$1" port="$2"
  if command_exists ss; then
    # ss: list listening TCP sockets on given port
    if ss -Hln "sport = :$port" 2>/dev/null | grep -q .; then
      return 1
    else
      return 0
    fi
  elif command_exists lsof; then
    if lsof -iTCP -sTCP:LISTEN -P -n 2>/dev/null | awk '{print $9}' | grep -Eq ":$port( |$)"; then
      return 1
    else
      return 0
    fi
  elif command_exists nc; then
    if nc -z "$host" "$port" >/dev/null 2>&1; then
      return 1
    else
      return 0
    fi
  else
    # Fallback: bash TCP check
    if (echo >/dev/tcp/"$host"/"$port") >/dev/null 2>&1; then
      return 1
    else
      return 0
    fi
  fi
}

find_free_port() {
  local host="$1" start="$2" max_increments=2000
  local p="$start"
  for _ in $(seq 0 "$max_increments"); do
    if is_port_free "$host" "$p"; then
      echo "$p"
      return 0
    fi
    p=$((p+1))
  done
  return 1
}

# Input validation functions
validate_host() {
  local host="$1"
  # Allow localhost, IPv4, IPv6, and valid hostnames
  if [[ "$host" =~ ^(localhost|127\.0\.0\.1|::1|0\.0\.0\.0)$ ]] || \
     [[ "$host" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]] || \
     [[ "$host" =~ ^[a-zA-Z0-9][a-zA-Z0-9\.-]*[a-zA-Z0-9]$ ]]; then
    return 0
  fi
  return 1
}

validate_port() {
  local port="$1"
  # Must be numeric and in valid range
  if [[ "$port" =~ ^[0-9]+$ ]] && [ "$port" -ge 1 ] && [ "$port" -le 65535 ]; then
    return 0
  fi
  return 1
}

validate_file_path() {
  local path="$1"
  local must_exist="$2"

  # Prevent path traversal and dangerous paths
  case "$path" in
    */..* | */../* | ../* | */./* | /etc/* | /usr/* | /bin/* | /sbin/* | /var/* | /sys/* | /proc/*)
      return 1 ;;
  esac

  # Must be absolute or relative to current directory
  if [[ "$path" =~ ^[a-zA-Z0-9/_.-]+$ ]]; then
    if [ "$must_exist" = "true" ] && [ ! -f "$path" ]; then
      return 1
    fi
    return 0
  fi
  return 1
}

validate_threads() {
  local threads="$1"
  if [ "$threads" = "auto" ]; then
    return 0
  fi
  if [[ "$threads" =~ ^[0-9]+$ ]] && [ "$threads" -ge 1 ] && [ "$threads" -le 256 ]; then
    return 0
  fi
  return 1
}

validate_time() {
  local time="$1"
  # Accept formats like: 30s, 5m, 1h, 120
  if [[ "$time" =~ ^[0-9]+[smh]?$ ]]; then
    return 0
  fi
  return 1
}

# Load configuration before parsing arguments (CLI args will override config)
load_config

# Parse args with validation
while [ $# -gt 0 ]; do
  case "$1" in
    --host)
      if [ -z "$2" ]; then
        err "--host requires a value"; exit 2
      fi
      if ! validate_host "$2"; then
        err "Invalid host: $2 (must be localhost, valid IP, or hostname)"; exit 2
      fi
      HOST="$2"; shift 2;;
    --port|--start-port)
      if [ -z "$2" ]; then
        err "--port requires a value"; exit 2
      fi
      if ! validate_port "$2"; then
        err "Invalid port: $2 (must be 1-65535)"; exit 2
      fi
      START_PORT="$2"; shift 2;;
    --caddyfile)
      if [ -z "$2" ]; then
        err "--caddyfile requires a value"; exit 2
      fi
      if ! validate_file_path "$2" "false"; then
        err "Invalid Caddyfile path: $2 (path traversal not allowed)"; exit 2
      fi
      CADDYFILE="$2"; shift 2;;
    --docroot)
      if [ -z "$2" ]; then
        err "--docroot requires a value"; exit 2
      fi
      if ! validate_file_path "$2" "false"; then
        err "Invalid docroot path: $2 (path traversal not allowed)"; exit 2
      fi
      DOCROOT="$2"; shift 2;;
    --php-threads)
      if [ -z "$2" ]; then
        err "--php-threads requires a value"; exit 2
      fi
      if ! validate_threads "$2"; then
        err "Invalid PHP threads: $2 (must be 'auto' or 1-256)"; exit 2
      fi
      PHP_THREADS="$2"; shift 2;;
    --max-wait)
      if [ -z "$2" ]; then
        err "--max-wait requires a value"; exit 2
      fi
      if ! validate_time "$2"; then
        err "Invalid max wait time: $2 (use format like 30s, 5m, 1h)"; exit 2
      fi
      MAX_WAIT_TIME="$2"; shift 2;;
    --worker)
      WORKER_MODE=1; shift;;
    --watch)
      WATCH_MODE=1; shift;;
    --watch-pattern)
      if [ -z "$2" ]; then
        err "--watch-pattern requires a value"; exit 2
      fi
      # Basic validation for watch patterns
      if [[ "$2" =~ ^[a-zA-Z0-9*./,_-]+$ ]]; then
        WATCH_PATTERNS="${WATCH_PATTERNS}${WATCH_PATTERNS:+,}$2"
      else
        err "Invalid watch pattern: $2"; exit 2
      fi
      shift 2;;
    --https)
      if [ -z "$2" ]; then
        err "--https requires a value"; exit 2
      fi
      if [ "$2" != "off" ] && [ "$2" != "local" ] && [ "$2" != "on" ]; then
        err "Invalid HTTPS mode: $2 (must be: off, local, or on)"; exit 2
      fi
      HTTPS_MODE="$2"; shift 2;;
    --compression)
      COMPRESSION=1; shift;;
    --no-compression)
      COMPRESSION=0; shift;;
    --open|-o)
      OPEN_BROWSER=1; shift;;
    --no-open)
      OPEN_BROWSER=0; shift;;
    --xdebug)
      XDEBUG=1; shift;;
    --verbose|-v)
      VERBOSE=1; shift;;
    --env-file)
      if [ -z "$2" ]; then
        err "--env-file requires a value"; exit 2
      fi
      if ! validate_file_path "$2" "false"; then
        err "Invalid env file path: $2 (path traversal not allowed)"; exit 2
      fi
      ENV_FILE="$2"; shift 2;;
    --domain)
      if [ -z "$2" ]; then
        err "--domain requires a value"; exit 2
      fi
      # Convert to lowercase for consistency
      domain_input=$(echo "$2" | tr '[:upper:]' '[:lower:]')
      if ! validate_domain "$domain_input"; then
        err "Invalid domain: $2 (use format like myapp.test, myapp.local)"; exit 2
      fi
      DOMAIN="$domain_input"; shift 2;;
    --auto-domain)
      AUTO_DOMAIN=1; shift;;
    --no-hosts)
      MANAGE_HOSTS=0; shift;;
    --save)
      SAVE_MODE=1; shift;;
    --init)
      INIT_MODE=1; shift;;
    --force)
      FORCE_MODE=1; shift;;
    --install)
      INSTALL_MODE=1; shift;;
    --build-php)
      BUILD_PHP_MODE=1; shift;;
    --stop)
      STOP_MODE=1; shift;;
    --list)
      LIST_MODE=1; shift;;
    --stats)
      STATS_MODE=1; shift;;
    --dry-run)
      DRY_RUN=1; shift;;
    --quiet)
      QUIET=1; shift;;
    -h|--help)
      usage; exit 0;;
    --)
      shift
      # Validate extra args - only allow safe FrankenPHP arguments
      for arg in "$@"; do
        case "$arg" in
          *\;* | *\|* | *\&* | *\$* | *\`* | *\>* | *\<*)
            err "Invalid characters in extra arguments: $arg"; exit 2 ;;
        esac
      done
      EXTRA_ARGS=("$@")
      break;;
    *)
      err "Unknown option: $1"; usage; exit 2;;
  esac
done

# Handle auto-domain detection
if [ "$AUTO_DOMAIN" -eq 1 ] && [ -z "$DOMAIN" ]; then
  DOMAIN=$(infer_domain)
  log "üîç Auto-detected domain: $DOMAIN"
fi

# Helper to collect listeners for a PID
get_listeners_for_pid() {
  local pid="$1"
  if command_exists ss; then
    ss -Hlnpt 2>/dev/null | awk -v pid="$pid" '$0 ~ "pid="pid"," {print $4}' | sort -u
  elif command_exists lsof; then
    lsof -nP -iTCP -sTCP:LISTEN -p "$pid" 2>/dev/null | awk 'NR>1 {print $9}' | sort -u
  else
    echo "-"
  fi
}

# Cross-platform: get process command line
get_process_cmdline() {
  local pid="$1"
  if [ -f "/proc/$pid/cmdline" ]; then
    tr '\0' ' ' < "/proc/$pid/cmdline" 2>/dev/null || echo ""
  else
    ps -p "$pid" -o args= 2>/dev/null || echo ""
  fi
}

# Cross-platform: get process working directory
get_process_cwd() {
  local pid="$1"
  if [ -L "/proc/$pid/cwd" ]; then
    readlink "/proc/$pid/cwd" 2>/dev/null || echo "-"
  elif command_exists lsof; then
    lsof -p "$pid" -Fn 2>/dev/null | awk -F'n' '/^n\// && /cwd/ {print $2; exit}' || echo "-"
  else
    echo "-"
  fi
}

# Cross-platform: check if PID is owned by current user
is_own_process() {
  local pid="$1"
  if [ -d "/proc/$pid" ]; then
    [ "$(get_file_owner_uid "/proc/$pid")" = "$(id -u)" ]
  else
    # macOS / BSD fallback: check via ps
    local owner_uid
    owner_uid=$(ps -p "$pid" -o uid= 2>/dev/null | tr -d ' ')
    [ "$owner_uid" = "$(id -u)" ]
  fi
}

# Helper to get process statistics
get_process_stats() {
  local pid="$1"

  # Try Linux /proc first
  if [ -f "/proc/$pid/stat" ] && [ -f "/proc/$pid/status" ]; then
    local stats_file="/proc/$pid/stat"
    local status_file="/proc/$pid/status"

    # Get process start time and calculate uptime
    local starttime=$(awk '{print $22}' "$stats_file" 2>/dev/null)
    local boot_time=$(awk '/^btime/ {print $2}' /proc/stat 2>/dev/null)
    local uptime_seconds=0

    if [ -n "$starttime" ] && [ -n "$boot_time" ]; then
      local clock_ticks=$(getconf CLK_TCK 2>/dev/null || echo 100)
      local process_start_time=$((boot_time + starttime / clock_ticks))
      local current_time=$(date +%s)
      uptime_seconds=$((current_time - process_start_time))
    fi

    # Format uptime
    local uptime_formatted
    if [ "$uptime_seconds" -lt 60 ]; then
      uptime_formatted="${uptime_seconds}s"
    elif [ "$uptime_seconds" -lt 3600 ]; then
      uptime_formatted="$((uptime_seconds / 60))m"
    else
      uptime_formatted="$((uptime_seconds / 3600))h"
    fi

    # Get memory usage (RSS in kB)
    local memory_kb=$(awk '/^VmRSS:/ {print $2}' "$status_file" 2>/dev/null || echo "0")
    local memory_mb=$((memory_kb / 1024))
    local memory_formatted
    if [ "$memory_mb" -ge 1024 ]; then
      memory_formatted="$((memory_mb / 1024))GB"
    else
      memory_formatted="${memory_mb}MB"
    fi

    # Get open file descriptor count
    local fd_count
    if [ -d "/proc/$pid/fd" ]; then
      fd_count=$(ls /proc/$pid/fd 2>/dev/null | wc -l)
    else
      fd_count="-"
    fi

    # Get thread count
    local threads=$(awk '/^Threads:/ {print $2}' "$status_file" 2>/dev/null || echo "-")

    echo "$uptime_formatted $memory_formatted $fd_count $threads"
  else
    # macOS / BSD fallback using ps
    local ps_output
    ps_output=$(ps -p "$pid" -o etime=,rss= 2>/dev/null)
    if [ -z "$ps_output" ]; then
      echo "- - - -"
      return
    fi

    local etime rss_kb
    etime=$(echo "$ps_output" | awk '{print $1}')
    rss_kb=$(echo "$ps_output" | awk '{print $2}')

    # Format elapsed time (ps gives [[dd-]hh:]mm:ss)
    local uptime_formatted="$etime"

    # Format memory
    local memory_mb=$(( (rss_kb + 512) / 1024 ))
    local memory_formatted
    if [ "$memory_mb" -ge 1024 ]; then
      memory_formatted="$((memory_mb / 1024))GB"
    else
      memory_formatted="${memory_mb}MB"
    fi

    echo "$uptime_formatted $memory_formatted - -"
  fi
}

# Helper: list running FrankenPHP instances owned by current user
list_instances() {
  log "üîé Listing FrankenPHP processes for current user..."

  local PIDS
  PIDS=$(pgrep -f "frankenphp" -u "$(id -u)" 2>/dev/null || true)

  if [ -z "$PIDS" ]; then
    echo "No FrankenPHP processes found for current user."
    return 0
  fi


  # Print header
  printf "%s\n" "PID     LISTEN                MODE     STARTED FROM                        CONFIG"

  local pid cmdline config listeners mode docroot workdir
  for pid in $PIDS; do
    # Validate ownership
    if ! is_own_process "$pid"; then
      continue
    fi

    cmdline=$(get_process_cmdline "$pid")
    workdir=$(get_process_cwd "$pid")

    # Shorten path for display if too long
    if [ "${#workdir}" -gt 35 ] && [ "$workdir" != "-" ]; then
      workdir="...${workdir: -32}"
    fi

    # Extract --config value (best-effort)
    config=$(printf '%s' "$cmdline" | sed -n 's/.*--config \([^ ]\+\).*/\1/p')
    [ -z "$config" ] && config="-"

    # Shorten config path for display
    if [ "${#config}" -gt 25 ] && [ "$config" != "-" ]; then
      config="...${config: -22}"
    fi

    # Determine listeners
    listeners=$(get_listeners_for_pid "$pid" | paste -sd, -)
    [ -z "$listeners" ] && listeners="-"

    # Determine mode from config (best-effort)
    mode="-"
    if [ -f "$config" ]; then
      if grep -qE "^[[:space:]]*worker[[:space:]]*\{" "$config" 2>/dev/null; then
        mode="worker"
      else
        mode="classic"
      fi
    fi

    printf "%-7s %-20s %-8s %-35s %s\n" "$pid" "${listeners}" "$mode" "$workdir" "$config"
  done
}

# Show detailed statistics for running processes
stats_instances() {
  log "üìä Gathering statistics for FrankenPHP processes..."

  local PIDS
  PIDS=$(pgrep -f "frankenphp" -u "$(id -u)" 2>/dev/null || true)

  if [ -z "$PIDS" ]; then
    echo "No FrankenPHP processes found for current user."
    return 0
  fi

  # Print header
  printf "%s\n" "PID     LISTEN           MODE     UPTIME  MEMORY  FILES THREADS  STARTED FROM"

  local pid cmdline config listeners mode workdir stats_info
  for pid in $PIDS; do
    # Validate ownership
    if ! is_own_process "$pid"; then
      continue
    fi

    cmdline=$(get_process_cmdline "$pid")
    workdir=$(get_process_cwd "$pid")
    if [ "${#workdir}" -gt 25 ] && [ "$workdir" != "-" ]; then
      workdir="...${workdir: -22}"
    fi

    # Extract config
    config=$(printf '%s' "$cmdline" | sed -n 's/.*--config \([^ ]\+\).*/\1/p')
    [ -z "$config" ] && config="-"

    # Determine listeners
    listeners=$(get_listeners_for_pid "$pid" | paste -sd, -)
    [ -z "$listeners" ] && listeners="-"
    if [ "${#listeners}" -gt 15 ]; then
      listeners="${listeners:0:12}..."
    fi

    # Determine mode
    mode="-"
    if [ -f "$config" ]; then
      if grep -qE "^[[:space:]]*worker[[:space:]]*\{" "$config" 2>/dev/null; then
        mode="worker"
      else
        mode="classic"
      fi
    fi

    # Get statistics
    stats_info=$(get_process_stats "$pid")

    printf "%-7s %-15s %-8s %s  %s\n" "$pid" "${listeners}" "$mode" "$stats_info" "$workdir"
  done
}

# Handle stop mode - kill all FrankenPHP processes
if [ "$STOP_MODE" -eq 1 ]; then
  log "üõë Stopping all FrankenPHP processes..."

  # Find FrankenPHP processes owned by current user only (security improvement)
  # Use pattern that matches FrankenPHP commands - simplified for compatibility
  PIDS=$(pgrep -f "frankenphp" -u "$(id -u)" 2>/dev/null || true)

  if [ -z "$PIDS" ]; then
    log "‚ÑπÔ∏è  No FrankenPHP processes found for current user."
    exit 0
  fi

  # Validate PIDs and check ownership before killing
  VALID_PIDS=""
  for pid in $PIDS; do
    if is_own_process "$pid"; then
      VALID_PIDS="${VALID_PIDS} $pid"
    fi
  done

  if [ -z "$VALID_PIDS" ]; then
    log "‚ÑπÔ∏è  No valid FrankenPHP processes found for current user."
    exit 0
  fi

  # Count valid processes
  PROCESS_COUNT=$(echo "$VALID_PIDS" | wc -w)
  log "üîç Found $PROCESS_COUNT valid FrankenPHP process(es). Sending SIGTERM..."

  # Send SIGTERM to valid processes only
  for pid in $VALID_PIDS; do
    if kill -0 "$pid" 2>/dev/null; then
      kill -TERM "$pid" 2>/dev/null || log "‚ö†Ô∏è  Could not send SIGTERM to PID $pid"
    fi
  done

  # Wait for graceful shutdown
  sleep 3

  # Check if any processes are still running and force kill if needed
  REMAINING_PIDS=""
  for pid in $VALID_PIDS; do
    if kill -0 "$pid" 2>/dev/null; then
      REMAINING_PIDS="${REMAINING_PIDS} $pid"
    fi
  done

  if [ -n "$REMAINING_PIDS" ]; then
    REMAINING_COUNT=$(echo "$REMAINING_PIDS" | wc -w)
    log "üí• Force killing $REMAINING_COUNT stubborn process(es) with SIGKILL..."
    for pid in $REMAINING_PIDS; do
      kill -KILL "$pid" 2>/dev/null || log "‚ö†Ô∏è  Could not send SIGKILL to PID $pid"
    done
    sleep 1
  fi

  # Final verification
  STILL_RUNNING=""
  for pid in $VALID_PIDS; do
    if kill -0 "$pid" 2>/dev/null; then
      STILL_RUNNING="${STILL_RUNNING} $pid"
    fi
  done

  if [ -z "$STILL_RUNNING" ]; then
    log "‚úÖ All FrankenPHP processes have been stopped."
  else
    log "‚ö†Ô∏è  Some processes are still running (PIDs:$STILL_RUNNING). Manual intervention may be required."
  fi

  exit 0
fi

# Handle list mode
if [ "$LIST_MODE" -eq 1 ]; then
  list_instances
  exit 0
fi

# Handle stats mode
if [ "$STATS_MODE" -eq 1 ]; then
  stats_instances
  exit 0
fi

# Handle --install mode
if [ "$INSTALL_MODE" -eq 1 ]; then
  log "üì¶ Installing phpup to /usr/local/bin/"

  # Check if script exists
  SCRIPT_PATH="$(realpath "$0")"
  if [ ! -f "$SCRIPT_PATH" ]; then
    err "Cannot determine script path"
    exit 1
  fi

  # Check if we have write permission to /usr/local/bin
  if [ ! -w /usr/local/bin ] && [ "$EUID" -ne 0 ]; then
    log "‚ö†Ô∏è  Need sudo permission to install to /usr/local/bin/"
    log "   Please run: sudo $0 --install"
    exit 1
  fi

  # Check if already installed to avoid copying file to itself
  if [ "$SCRIPT_PATH" = "/usr/local/bin/phpup" ]; then
    log "‚ö†Ô∏è  phpup is already installed at /usr/local/bin/phpup"
    log "   Running from the same location - no update needed"
  elif [ -f "/usr/local/bin/phpup" ]; then
    log "‚ö†Ô∏è  phpup is already installed at /usr/local/bin/phpup"
    printf "   Override existing installation? [y/N]: "
    read -r response
    case "$response" in
      [yY]|[yY][eE][sS])
        log "üîÑ Overriding existing installation..."
        cp "$SCRIPT_PATH" /usr/local/bin/phpup || {
          err "Failed to copy phpup to /usr/local/bin/"
          exit 1
        }
        log "‚úÖ Successfully updated phpup at /usr/local/bin/"
        ;;
      *)
        log "‚ùå Installation cancelled"
        exit 0
        ;;
    esac
  else
    # Copy the script (first time installation)
    cp "$SCRIPT_PATH" /usr/local/bin/phpup || {
      err "Failed to copy phpup to /usr/local/bin/"
      exit 1
    }
    log "‚úÖ Successfully installed phpup to /usr/local/bin/"
  fi

  # Make it executable
  chmod +x /usr/local/bin/phpup || {
    err "Failed to make phpup executable"
    exit 1
  }


  # Check if FrankenPHP is available
  if ! command_exists frankenphp; then
    log "üöÄ FrankenPHP not found, attempting to install..."

    # Download and install FrankenPHP
    if command_exists curl; then
      log "   Downloading FrankenPHP installer..."

      # Create temp file for installer (safer than piping to sh)
      INSTALLER_TMP=$(mktemp -t phpup-frankenphp-installer.XXXXXX) || {
        err "Failed to create temp file for installer"
        exit 1
      }
      trap "rm -f '$INSTALLER_TMP'" EXIT

      # Download installer script first
      if curl -fsSL https://frankenphp.dev/install.sh -o "$INSTALLER_TMP"; then
        chmod +x "$INSTALLER_TMP"
        log "   Running FrankenPHP installer..."

        if sh "$INSTALLER_TMP"; then
          rm -f "$INSTALLER_TMP"

          if [ -f "./frankenphp" ]; then
            log "   Moving frankenphp to /usr/local/bin/..."
            mv ./frankenphp /usr/local/bin/ && chmod +x /usr/local/bin/frankenphp

            # Verify the binary works
            if /usr/local/bin/frankenphp version >/dev/null 2>&1; then
              log "‚úÖ FrankenPHP installed and verified successfully"
            else
              log "‚ö†Ô∏è  FrankenPHP installed but verification failed"
              log "   The binary may be corrupted. Try reinstalling manually: https://frankenphp.dev/docs/install/"
            fi
          else
            log "‚ö†Ô∏è  FrankenPHP download succeeded but binary not found in current directory"
            log "   You may need to install FrankenPHP manually: https://frankenphp.dev/docs/install/"
          fi
        else
          rm -f "$INSTALLER_TMP"
          log "‚ö†Ô∏è  Failed to run FrankenPHP installer"
          log "   Please install FrankenPHP manually: https://frankenphp.dev/docs/install/"
        fi
      else
        rm -f "$INSTALLER_TMP"
        log "‚ö†Ô∏è  Failed to download FrankenPHP installer"
        log "   Please install FrankenPHP manually: https://frankenphp.dev/docs/install/"
      fi
    else
      log "‚ö†Ô∏è  curl not found - cannot auto-install FrankenPHP"
      log "   Please install FrankenPHP manually: https://frankenphp.dev/docs/install/"
    fi
  else
    log "‚úÖ FrankenPHP is already available"
  fi

  log "   You can now run 'phpup' from anywhere"
  exit 0
fi

# Handle --build-php mode
if [ "$BUILD_PHP_MODE" -eq 1 ]; then
  log "üî® FrankenPHP Custom Build Helper"
  log ""
  log "This helper will guide you through building a custom FrankenPHP binary"
  log "with additional PHP extensions like Xdebug, MongoDB, etc."
  log ""

  # Check prerequisites
  if ! command_exists docker; then
    err "Docker is required to build custom FrankenPHP binaries"
    log "Please install Docker first: https://docs.docker.com/get-docker/"
    exit 1
  fi

  # Check docker buildx
  if ! docker buildx version >/dev/null 2>&1; then
    err "docker buildx is required for building custom FrankenPHP"
    log "Please install docker buildx: https://docs.docker.com/buildx/working-with-buildx/"
    exit 1
  fi

  # Check Docker permissions
  if ! docker info >/dev/null 2>&1; then
    log "‚ö†Ô∏è  Docker permission issue detected"
    log ""
    log "To fix this, you can either:"
    log "1. Add your user to the docker group:"
    log "   sudo usermod -aG docker $USER"
    log "   newgrp docker  # or logout/login"
    log ""
    log "2. Or run this command with sudo:"
    log "   sudo ./phpup --build-php"
    log ""
    echo -n "Try to continue with sudo? (y/N): "
    read -r use_sudo

    if [ "$use_sudo" = "y" ] || [ "$use_sudo" = "Y" ]; then
      if [ "$EUID" -eq 0 ]; then
        log "‚úÖ Already running as root, continuing..."
      else
        log "üîÑ Re-running with sudo..."
        exec sudo "$0" --build-php
      fi
    else
      log "‚ùå Cannot proceed without Docker access. Exiting."
      exit 1
    fi
  fi

  if ! command_exists git; then
    err "Git is required to clone the FrankenPHP repository"
    log "Please install Git first"
    exit 1
  fi

  log "üêò Available PHP versions:"
  log "   ‚Ä¢ 8.4 (latest)  - PHP 8.4.x"
  log "   ‚Ä¢ 8.3          - PHP 8.3.x (stable)"
  log "   ‚Ä¢ 8.2          - PHP 8.2.x"
  log "   ‚Ä¢ 8.1          - PHP 8.1.x"
  log ""

  # PHP version selection
  echo -n "Enter PHP version (8.1, 8.2, 8.3, 8.4) [default: 8.4]: "
  read -r php_version

  if [ -z "$php_version" ]; then
    php_version="8.4"
  fi

  # Validate PHP version
  case "$php_version" in
    8.1|8.2|8.3|8.4)
      log "‚úÖ Selected PHP $php_version"
      ;;
    *)
      err "Invalid PHP version: $php_version. Must be 8.1, 8.2, 8.3, or 8.4"
      exit 1
      ;;
  esac

  log ""
  log "üìã Available extensions you can add:"
  log "   ‚Ä¢ xdebug        - Step debugger and profiler"
  log "   ‚Ä¢ mongodb       - MongoDB driver"
  log "   ‚Ä¢ swoole        - Async programming framework"
  log "   ‚Ä¢ redis         - Redis client (if not already included)"
  log "   ‚Ä¢ memcached     - Memcached client (if not already included)"
  log "   ‚Ä¢ imagick       - ImageMagick extension (if not already included)"
  log "   ‚Ä¢ gd            - GD graphics library (if not already included)"
  log "   ‚Ä¢ custom        - Custom extensions via Dockerfile"
  log ""

  # Interactive selection
  echo -n "Enter extensions to add (comma-separated, e.g., 'xdebug,mongodb'): "
  read -r extensions

  if [ -z "$extensions" ]; then
    log "‚ùå No extensions specified. Exiting."
    exit 1
  fi

  # Validate and prepare build
  log ""
  log "üèóÔ∏è  Preparing custom build with PHP $php_version and extensions: $extensions"
  log ""

  # Create secure build directory
  BUILD_DIR=$(mktemp -d -t frankenphp-custom-build.XXXXXX)
  chmod 700 "$BUILD_DIR"
  cd "$BUILD_DIR" || exit 1

  log "üì• Cloning FrankenPHP repository..."
  if ! git clone https://github.com/dunglas/frankenphp.git .; then
    err "Failed to clone FrankenPHP repository"
    exit 1
  fi

  # Build extensions list
  log "üìù Preparing build configuration..."

  # Convert extensions to build format
  php_extensions=""
  IFS=',' read -ra EXT_ARRAY <<< "$extensions"
  for ext in "${EXT_ARRAY[@]}"; do
    ext=$(echo "$ext" | xargs) # trim whitespace
    case "$ext" in
      custom)
        log "üìù For custom extensions, you'll need to manually edit docker-bake.override.hcl"
        ;;
      *)
        if [ -z "$php_extensions" ]; then
          php_extensions="$ext"
        else
          php_extensions="$php_extensions,$ext"
        fi
        ;;
    esac
  done

  log "üî® Building custom FrankenPHP binary (this may take 10-20 minutes)..."
  log "   Build directory: $BUILD_DIR"
  log "   PHP version: $php_version"
  log "   Extensions: $php_extensions"

  # Use docker buildx bake for proper static builds
  if command_exists docker && docker buildx version >/dev/null 2>&1; then
    # Change to the FrankenPHP source directory for build
    cd "$BUILD_DIR" || {
      err "Failed to change to build directory: $BUILD_DIR"
      exit 1
    }

    # Build using the official FrankenPHP build system
    # Add platform specification to avoid manifest list export issues
    PLATFORM=$(uname -m)
    case "$PLATFORM" in
      x86_64) DOCKER_PLATFORM="linux/amd64" ;;
      aarch64|arm64) DOCKER_PLATFORM="linux/arm64" ;;
      *) DOCKER_PLATFORM="linux/amd64" ;;  # default fallback
    esac

    if docker buildx bake --load \
      --set static-builder-gnu.platform="$DOCKER_PLATFORM" \
      --set static-builder-gnu.args.PHP_EXTENSIONS="$php_extensions" \
      static-builder-gnu; then
      log ""
      log "üéâ Build completed successfully!"
      log ""
      log "üì¶ Extracting binary..."

      # Create secure extraction directory
      EXTRACT_DIR=$(mktemp -d -t frankenphp-extract.XXXXXX)
      chmod 700 "$EXTRACT_DIR"

      # Extract the binary from the built image using the official method
      ARCH=$(uname -m)
      CONTAINER_NAME="frankenphp-extract-$$"

      if docker create --name "$CONTAINER_NAME" dunglas/frankenphp:static-builder-gnu >/dev/null 2>&1; then
        if docker cp "$CONTAINER_NAME:/go/src/app/dist/frankenphp-linux-$ARCH" "$EXTRACT_DIR/frankenphp-custom" >/dev/null 2>&1; then
          docker rm "$CONTAINER_NAME" >/dev/null 2>&1
          chmod +x "$EXTRACT_DIR/frankenphp-custom"

          log "‚úÖ Custom FrankenPHP binary created: $EXTRACT_DIR/frankenphp-custom"
          log ""
          log "üöÄ To use your custom binary:"
          log "   1. Backup current FrankenPHP: sudo mv /usr/local/bin/frankenphp /usr/local/bin/frankenphp.backup"
          log "   2. Install custom binary: sudo cp $EXTRACT_DIR/frankenphp-custom /usr/local/bin/frankenphp"
          log "   3. Test with: frankenphp version"
          log ""
          log "üóëÔ∏è  To clean up:"
          log "   Build directory: rm -rf $BUILD_DIR"
          log "   Binary: rm -rf $EXTRACT_DIR"
        else
          docker rm "$CONTAINER_NAME" >/dev/null 2>&1
          err "Failed to copy binary from container"
          exit 1
        fi
      else
        err "Failed to create container from built image"
        exit 1
      fi
    else
      err "Build failed. Check the output above for errors."
      log "Build directory preserved at: $BUILD_DIR"
      exit 1
    fi
  else
    err "docker buildx is required for building custom FrankenPHP"
    log "Please install docker buildx: https://docs.docker.com/buildx/working-with-buildx/"
    exit 1
  fi

  exit 0
fi

if [ "$INIT_MODE" -eq 1 ]; then
  log "‚öôÔ∏è  Initializing .phpup/ configuration directory..."
  if [ "$FORCE_MODE" -eq 1 ]; then
    log "   (--force enabled: existing files will be overwritten)"
  fi

  # Create directories
  mkdir -p .phpup .phpup/sessions

  # Detect docroot for configuration
  if [ -z "$DOCROOT" ]; then
    if [ -d "public" ]; then
      DOCROOT="$(pwd)/public"
    elif [ -d "web" ]; then
      DOCROOT="$(pwd)/web"
    elif [ -d "www" ]; then
      DOCROOT="$(pwd)/www"
    else
      DOCROOT="$(pwd)"
    fi
  fi

  # Set default values for template generation
  HOST="${HOST:-127.0.0.1}"
  PORT="${START_PORT:-8000}"

  # Generate unified PHP configuration
  generate_php_config() {
    local php_ini_file=".phpup/php.ini"

    if [ -f "$php_ini_file" ] && [ "$FORCE_MODE" -ne 1 ]; then
      log "PHP configuration already exists: $php_ini_file"
      log "Use --force to overwrite existing files"
      return 0
    fi

    # Universal PHP settings optimized for both classic and worker modes
    cat > "$php_ini_file" <<EOF
; Universal PHP configuration for FrankenPHP
; Optimized for both classic and worker modes

; Memory and execution limits (balanced for both modes)
memory_limit = 256M
max_execution_time = 60
max_input_time = 60

; Error reporting (development-friendly)
display_errors = On
display_startup_errors = On
error_reporting = E_ALL
log_errors = On
error_log = .phpup/php_errors.log

; File uploads (generous limits)
upload_max_filesize = 50M
post_max_size = 50M
max_file_uploads = 20

; Sessions (secure defaults)
session.save_path = .phpup/sessions
session.gc_maxlifetime = 1440
session.cookie_httponly = On
session.use_strict_mode = On
session.cookie_secure = Off
session.cookie_samesite = "Lax"

; OPcache (optimized for performance)
opcache.enable = 1
opcache.memory_consumption = 128
opcache.max_accelerated_files = 10000
opcache.revalidate_freq = 2
opcache.validate_timestamps = 1
opcache.save_comments = 1
opcache.enable_file_override = 1

; JIT (if available in PHP 8+)
opcache.jit_buffer_size = 64M
opcache.jit = 1255

; Security
expose_php = Off
allow_url_fopen = On
allow_url_include = Off

; Performance (optimized for both modes)
realpath_cache_size = 8192K
realpath_cache_ttl = 300

; Development helpers
auto_prepend_file =
auto_append_file =

; Timezone
date.timezone = UTC

; FrankenPHP compatibility
; These settings work well with both classic and worker modes

; Enable assertions for development (can be disabled in production)
assert.active = 1
assert.exception = 1

; Worker mode compatibility
; Uncomment the following line to disable exit() in worker mode if needed
; disable_functions = exit

; Additional performance settings
max_input_vars = 1000
variables_order = "GPCS"
request_order = "GP"

; File handling
file_uploads = On
auto_detect_line_endings = Off

; Resource limits
max_input_nesting_level = 64
max_input_time = 60

; Output handling
output_buffering = 4096
implicit_flush = Off

; Safe mode (deprecated but some settings still relevant)
; User and group restrictions are handled by the system

; MySQL/MariaDB defaults
default_socket_timeout = 60

; Mail function (adjust as needed)
sendmail_path = "/usr/sbin/sendmail -t -i"

; Xdebug (disabled by default - uncomment to enable)
; zend_extension=xdebug.so
; xdebug.mode=debug
; xdebug.start_with_request=yes
; xdebug.client_host=127.0.0.1
; xdebug.client_port=9003
; xdebug.idekey=PHPSTORM
; xdebug.log=/tmp/xdebug.log
; xdebug.log_level=7
EOF

    log "üìÑ Generated PHP configuration: $php_ini_file"
  }

  # Generate Caddyfile templates
  generate_caddyfile_template() {
    local mode="$1"
    local caddyfile_path=".phpup/Caddyfile.$mode"

    if [ -f "$caddyfile_path" ] && [ "$FORCE_MODE" -ne 1 ]; then
      log "Caddyfile already exists: $caddyfile_path"
      log "Use --force to overwrite existing files"
      return 0
    fi

    if [ "$mode" = "classic" ]; then
      cat > "$caddyfile_path" <<EOF
# phpup classic mode Caddyfile
# Generated with detected docroot: ${DOCROOT}
# Host: ${HOST}  Port: ${PORT}
{
  auto_https off
  frankenphp {
    num_threads 2
    max_threads 10
    php_ini {
      memory_limit 256M
      max_execution_time 60
      file_uploads On
      upload_max_filesize 50M
      post_max_size 50M
      max_file_uploads 20
      upload_tmp_dir /tmp
      session.save_path {\$PHPUP_DIR}/sessions
      display_errors On
      error_reporting E_ALL
      log_errors On
      error_log {\$PHPUP_DIR}/php_errors.log
    }
  }
  servers {
    timeouts {
      read_body 30s
      read_header 10s
      write 30s
      idle 2m
    }
  }
}

{\$PROTOCOL}://{\$HOST}:{\$PORT} {
  root * "{\$DOCROOT}"
  encode zstd gzip
  php_server


  @static {
    file
    not path_regexp \\.php$
    not path /
  }
  handle @static {
    file_server
  }

  # Generic subfolder application routing
  @subapp_routes {
    path_regexp subapp ^/([^/]+)/(.*)$
    file {re.subapp.1}/index.php
  }
  handle @subapp_routes {
    rewrite * /{re.subapp.1}/index.php?{query}
  }


  # Default fallback - must come last
  handle {
    try_files {path} /index.php?{query}
  }
  header *.{js,css,woff,woff2,ttf} Cache-Control "public, max-age=604800"
  header {
    X-Powered-By "FrankenPHP Classic"
  }

  log {
    output file {\$PHPUP_DIR}/access.log {
      roll_size 10mb
      roll_keep 3
    }
    format json
  }
}
EOF
    else  # worker mode
      # Determine worker file
      WORKER_FILE="${DOCROOT}/index.php"
      if [ -f "${DOCROOT}/public/index.php" ]; then
        WORKER_FILE="${DOCROOT}/public/index.php"
      elif [ -f "${DOCROOT}/app.php" ]; then
        WORKER_FILE="${DOCROOT}/app.php"
      fi

      cat > "$caddyfile_path" <<EOF
# phpup worker mode Caddyfile
# Generated with detected docroot: ${DOCROOT}
# Host: ${HOST}  Port: ${PORT}
{
  auto_https off
  frankenphp {
    num_threads 4
    php_ini {
      memory_limit 256M
      max_execution_time 60
      file_uploads On
      upload_max_filesize 50M
      post_max_size 50M
      max_file_uploads 20
      upload_tmp_dir /tmp
      session.save_path {\$PHPUP_DIR}/sessions
      display_errors On
      error_reporting E_ALL
      log_errors On
      error_log {\$PHPUP_DIR}/php_errors.log
    }
    worker {
      file "{\$WORKER_FILE}"
      num 2
      watch **/*.php
      env APP_ENV development
      env APP_DEBUG true
    }
  }
}

{\$PROTOCOL}://{\$HOST}:{\$PORT} {
  root * "{\$DOCROOT}"
  encode zstd gzip
  php_server

  # Static files
  file_server
  header {
    X-Powered-By "FrankenPHP Worker"
  }

  log {
    output file {\$PHPUP_DIR}/access.log {
      roll_size 10mb
      roll_keep 3
    }
    format json
  }
}
EOF
    fi

    log "üìÑ Generated $mode mode Caddyfile: $caddyfile_path"
  }

  # Generate configuration files
  generate_php_config
  generate_caddyfile_template "classic"
  generate_caddyfile_template "worker"

  # Generate a main Caddyfile that points to classic by default
  if [ ! -f ".phpup/Caddyfile" ]; then
    cat > ".phpup/Caddyfile" <<EOF
# Main Caddyfile - edit this file to customize your configuration
# Or rename one of the templates below:
#   - Caddyfile.classic: Traditional PHP processing
#   - Caddyfile.worker:  Worker mode with file watching
#
# To use a specific template, rename it to Caddyfile or use --caddyfile option

import Caddyfile.classic
EOF
    log "üìÑ Generated main Caddyfile: .phpup/Caddyfile"
  fi

  log ""
  log "‚úÖ Configuration files generated in .phpup/"
  log "üìÅ Files created:"
  log "   php.ini           - PHP configuration (memory, errors, uploads, etc.)"
  log "   Caddyfile         - Main Caddyfile (imports classic by default)"
  log "   Caddyfile.classic - Classic mode template (with inline php_ini)"
  log "   Caddyfile.worker  - Worker mode template (with inline php_ini)"
  log ""
  log "üìä Log files (created at runtime):"
  log "   php_errors.log    - PHP error log (configured in php.ini)"
  log "   access.log        - HTTP access log (JSON format, 10MB rotation)"
  log ""

  # Save configuration if requested or if domain is set
  if [ "$SAVE_MODE" -eq 1 ] || [ -n "$DOMAIN" ]; then
    save_config
  fi

  log "üîß Next steps:"
  log "   1. Edit .phpup/php.ini to customize PHP settings"
  log "   2. Edit .phpup/Caddyfile to customize server configuration"
  log "   3. Run './phpup' to start the server with your custom config"
  log "   4. Check .phpup/php_errors.log for PHP errors"
  log ""
  exit 0
fi

# Ensure FrankenPHP is available
if ! command_exists frankenphp; then
  err "'frankenphp' binary not found in PATH. Please install FrankenPHP or ensure it's available."
  exit 127
fi

# Safe .env file loader - only processes KEY=VALUE pairs
load_env_file() {
  local env_file="$1"
  local context="$2"

  if [ ! -f "$env_file" ]; then
    return 0
  fi

  if [ ! -r "$env_file" ]; then
    err "Cannot read env file: $env_file (permission denied)"
    return 1
  fi

  log "üîß $context: $env_file"

  # Parse .env file safely - only accept KEY=VALUE format
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip empty lines and comments
    case "$line" in
      ''|'#'*) continue ;;
    esac

    # Only process valid KEY=VALUE lines (no spaces around =, valid variable names)
    if [[ "$line" =~ ^[a-zA-Z_][a-zA-Z0-9_]*=.*$ ]]; then
      # Extract key and value
      key="${line%%=*}"
      value="${line#*=}"

      # Validate key name (alphanumeric + underscore, not starting with number)
      if [[ "$key" =~ ^[a-zA-Z_][a-zA-Z0-9_]*$ ]]; then
        # Remove quotes if present (simple quote removal, not full shell parsing)
        if [[ "$value" =~ ^\".*\"$ ]] || [[ "$value" =~ ^\'.*\'$ ]]; then
          value="${value#?}"  # Remove first character
          value="${value%?}"  # Remove last character
        fi

        # Export the variable safely
        export "$key=$value"
      else
        err "Invalid environment variable name in $env_file: $key"
      fi
    else
      # Log suspicious lines but don't fail
      if [ "$VERBOSE" -eq 1 ]; then
        log "‚ö†Ô∏è  Skipping invalid line in $env_file: $line"
      fi
    fi
  done < "$env_file"
}

# Load env file if specified
if [ -n "$ENV_FILE" ]; then
  load_env_file "$ENV_FILE" "Loading environment from"
fi

# Auto-load .phpup/.env if it exists
load_env_file ".phpup/.env" "Auto-loading environment from"

# Apply security hardening
secure_files

# Run security checks (but don't fail - just warn)
if [ "$QUIET" -ne 1 ]; then
  security_checks >/dev/null 2>&1 || true
fi

# Check system resources
if [ "$VERBOSE" -eq 1 ]; then
  debug "Checking system resources..."
  check_system_resources >/dev/null 2>&1 || true
fi

# Handle domain setup (mkcert + /etc/hosts)
if [ -n "$DOMAIN" ]; then
  log "üåê Setting up domain: $DOMAIN"

  # Update HOST to use domain if not explicitly set by user
  if [ "$HOST" = "127.0.0.1" ]; then
    HOST="$DOMAIN"
  fi

  # Setup mkcert and generate certificate for local HTTPS
  if [ "$HTTPS_MODE" = "local" ]; then
    if check_mkcert || setup_mkcert; then
      generate_cert "$DOMAIN" || log "‚ö†Ô∏è  Failed to generate SSL certificate for $DOMAIN"
    else
      log "‚ö†Ô∏è  mkcert setup failed - HTTPS will not work for custom domain"
    fi
  fi

  # Manage /etc/hosts entry
  if [ "$MANAGE_HOSTS" -eq 1 ]; then
    if manage_hosts_entry "add" "$DOMAIN" "127.0.0.1"; then
      HOSTS_ENTRY_ADDED=1
    else
      log "‚ö†Ô∏è  Failed to add domain to /etc/hosts"
    fi
  fi
fi

# Save configuration if requested
if [ "$SAVE_MODE" -eq 1 ]; then
  save_config
fi

# Validate options
if [ "$HTTPS_MODE" != "off" ] && [ "$HTTPS_MODE" != "local" ] && [ "$HTTPS_MODE" != "on" ]; then
  err "Invalid --https mode: $HTTPS_MODE (must be: off, local, or on)"
  exit 2
fi

# Detect docroot if not provided
if [ -z "$DOCROOT" ]; then
  if [ -d "public" ]; then
    DOCROOT="$(pwd)/public"
  elif [ -d "web" ]; then
    DOCROOT="$(pwd)/web"
  elif [ -d "www" ]; then
    DOCROOT="$(pwd)/www"
  else
    DOCROOT="$(pwd)"
  fi
fi

# Detect Caddyfile if not provided
if [ -z "$CADDYFILE" ]; then
  # First check for custom Caddyfiles
  for f in \
    ".phpup/Caddyfile" \
    "Caddyfile.local" \
    "Caddyfile.dev" \
    "Caddyfile" \
    "caddy/Caddyfile" \
    "config/Caddyfile" \
    ".Caddyfile"
  do
    if [ -f "$f" ]; then
      CADDYFILE="$f"
      break
    fi
  done

  # If no custom Caddyfile found, check for previously generated mode-specific files
  if [ -z "$CADDYFILE" ]; then
    # Determine which mode we'll be running in
    DETECT_WORKER_MODE=$WORKER_MODE
    if [ "$WATCH_MODE" -eq 1 ] && [ "$WORKER_MODE" -eq 0 ]; then
      DETECT_WORKER_MODE=1
    fi

    if [ "$DETECT_WORKER_MODE" -eq 1 ]; then
      # Check for worker mode Caddyfile
      if [ -f ".phpup/Caddyfile.worker" ]; then
        CADDYFILE=".phpup/Caddyfile.worker"
      fi
    else
      # Check for classic mode Caddyfile
      if [ -f ".phpup/Caddyfile.classic" ]; then
        CADDYFILE=".phpup/Caddyfile.classic"
      fi
    fi
  fi
fi

FINAL_CADDYFILE=""

# Always compute a free port so we can bind deterministically
# Determine port based on HTTPS mode
if [ "$HTTPS_MODE" = "on" ]; then
  # For production HTTPS, try standard HTTPS port
  if [ "$START_PORT" = "8000" ]; then
    START_PORT="443"
  fi
fi

# Discover a free port starting from the requested value
AVAILABLE_PORT=$(find_free_port "$HOST" "$START_PORT") || {
  err "‚ùå Did not find any free port starting at $START_PORT"
  log "Tried 2001 consecutive ports without success."
  log "You can pick an explicit port with --port or stop other listeners."
  exit 1
}

if [ "$AVAILABLE_PORT" != "$START_PORT" ]; then
  log "‚ÑπÔ∏è  Port $START_PORT is busy, switching to $AVAILABLE_PORT"
fi

PORT="$AVAILABLE_PORT"

# Set protocol based on HTTPS mode
if [ "$HTTPS_MODE" = "off" ]; then
  PROTOCOL="http"
else
  PROTOCOL="https"
fi

# Detect worker file for exports
WORKER_FILE="${DOCROOT}/index.php"
if [ -f "${DOCROOT}/public/index.php" ]; then
  WORKER_FILE="${DOCROOT}/public/index.php"
elif [ -f "${DOCROOT}/app.php" ]; then
  WORKER_FILE="${DOCROOT}/app.php"
fi

export HOST PORT DOCROOT PROTOCOL PHP_THREADS MAX_WAIT_TIME
# Also export variables used by the official FrankenPHP Caddyfile
export SERVER_NAME="${HOST}:${PORT}"
export SERVER_ROOT="${DOCROOT}"
# Compatibility alias sometimes used in community examples
export DOCUMENT_ROOT="${DOCROOT}"
# Worker file for worker mode templates
export WORKER_FILE="${WORKER_FILE}"
# Config directory for logs and certs
export PHPUP_DIR=".phpup"

if [ -n "$CADDYFILE" ]; then
  MODE="caddyfile"
  # With custom Caddyfile: compute free port and export env vars for placeholders
  FINAL_CADDYFILE="$CADDYFILE"
  log "üìÑ Using custom Caddyfile: $FINAL_CADDYFILE"
  log "üåç Env available to Caddyfile: HOST=$HOST PORT=$PORT DOCROOT=$DOCROOT SERVER_NAME=$SERVER_NAME SERVER_ROOT=$SERVER_ROOT WORKER_FILE=$WORKER_FILE PHPUP_DIR=$PHPUP_DIR"
  if frankenphp run --help >/dev/null 2>&1; then
    CMD=(frankenphp run --config "$FINAL_CADDYFILE")
  else
    CMD=(frankenphp start --config "$FINAL_CADDYFILE")
  fi

  if [ ${#EXTRA_ARGS[@]} -gt 0 ]; then
    CMD+=("${EXTRA_ARGS[@]}")
  fi

  if [ "$DRY_RUN" -ne 1 ]; then
    log "üöÄ Starting FrankenPHP (classic mode) at ${PROTOCOL}://$HOST:$PORT"
    log "üìÅ Docroot: $DOCROOT"
  fi
else
  # No custom Caddyfile: generate an optimized one in .phpup/Caddyfile
  mkdir -p .phpup .phpup/sessions

  # Determine if we're in worker mode (explicit or due to watch mode)
  EFFECTIVE_WORKER_MODE=$WORKER_MODE
  if [ "$WATCH_MODE" -eq 1 ] && [ "$WORKER_MODE" -eq 0 ]; then
    log "WARNING: File watching requires --worker mode. Adding --worker automatically."
    EFFECTIVE_WORKER_MODE=1
  fi

  # No external php.ini generation; settings are defined in inline php_ini blocks

  if [ "$EFFECTIVE_WORKER_MODE" -eq 1 ]; then
    # ====== WORKER MODE CADDYFILE ======
    FINAL_CADDYFILE=".phpup/Caddyfile.worker"

    # Configuration is provided inline via php_ini in the generated Caddyfile

    # Determine worker file
    WORKER_FILE="${DOCROOT}/index.php"
    if [ -f "${DOCROOT}/public/index.php" ]; then
      WORKER_FILE="${DOCROOT}/public/index.php"
    elif [ -f "${DOCROOT}/app.php" ]; then
      WORKER_FILE="${DOCROOT}/app.php"
    fi

    # Build global config for worker mode
    GLOBAL_CONFIG="{"

    # Admin API disabled
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  admin off"

    # HTTPS configuration
    if [ "$HTTPS_MODE" = "off" ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  auto_https off"
    elif [ "$HTTPS_MODE" = "local" ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  local_certs"
    fi

    # FrankenPHP worker configuration
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  frankenphp {"

    # Inline PHP configuration for worker mode
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    php_ini {"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      memory_limit 256M"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      max_execution_time 60"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      upload_max_filesize 50M"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      post_max_size 50M"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      max_file_uploads 20"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      session.save_path {\$PHPUP_DIR}/sessions"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      display_errors On"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      error_reporting E_ALL"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      log_errors On"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      error_log {\$PHPUP_DIR}/php_errors.log"
    if [ "$XDEBUG" -eq 1 ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      xdebug.mode debug"
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      xdebug.start_with_request yes"
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      xdebug.client_host 127.0.0.1"
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      xdebug.client_port 9003"
    fi
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    }"

    # Thread configuration for workers
    if [ "$PHP_THREADS" != "auto" ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    num_threads ${PHP_THREADS}"
    else
      # Optimal thread count for worker mode
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    num_threads 4"
    fi

    # Worker configuration with watch support
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    worker {"
    # Escape worker file path properly
    ESCAPED_WORKER_FILE=$(printf '%s' "$WORKER_FILE" | sed 's/"/\\"/g')
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      file \"${ESCAPED_WORKER_FILE}\""
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      num 2"

    if [ "$WATCH_MODE" -eq 1 ]; then
      WATCH_FILES="**/*.php"
      if [ -n "$WATCH_PATTERNS" ]; then
        # WATCH_PATTERNS already validated in argument parsing
        WATCH_FILES="${WATCH_FILES},${WATCH_PATTERNS}"
      fi
      # Quote watch patterns to prevent injection
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      watch \"${WATCH_FILES}\""
    fi

    # Worker-specific environment variables
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      env APP_ENV development"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      env APP_DEBUG true"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    }"

    # Max wait time for workers
    if [ "$MAX_WAIT_TIME" != "30s" ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    max_wait_time ${MAX_WAIT_TIME}"
    fi

    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  }"

    # Debug mode
    if [ "$VERBOSE" -eq 1 ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  debug"
    fi

    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n}"

    # Build site config for worker mode
    # Escape host and docroot for Caddyfile safety (already validated but defense in depth)
    ESCAPED_HOST=$(printf '%s' "$HOST" | sed 's/"/\\"/g')
    ESCAPED_DOCROOT=$(printf '%s' "$DOCROOT" | sed 's/"/\\"/g')

    # Handle custom domains with proper TLS configuration
    if [ -n "$DOMAIN" ]; then
      ESCAPED_DOMAIN=$(printf '%s' "$DOMAIN" | sed 's/"/\\"/g')
      if [ "$HTTPS_MODE" = "local" ]; then
        # Custom domain with HTTPS - include computed port
        SITE_CONFIG="https://${ESCAPED_DOMAIN}:${PORT} {"
        # Add TLS directive to use mkcert certificates
        SITE_CONFIG="${SITE_CONFIG}\n  tls {\\\$PHPUP_DIR}/certs/${ESCAPED_DOMAIN}.pem {\\\$PHPUP_DIR}/certs/${ESCAPED_DOMAIN}-key.pem"
      elif [ "$HTTPS_MODE" = "off" ]; then
        # Custom domain with HTTP
        SITE_CONFIG="http://${ESCAPED_DOMAIN}:${PORT} {"
      else
        # Custom domain with automatic HTTPS
        SITE_CONFIG="https://${ESCAPED_DOMAIN}:${PORT} {"
      fi
    else
      # No custom domain - use HOST:PORT
      if [ "$HTTPS_MODE" = "off" ]; then
        SITE_CONFIG="http://${ESCAPED_HOST}:${PORT} {"
      else
        SITE_CONFIG="${ESCAPED_HOST}:${PORT} {"
      fi
    fi
    SITE_CONFIG="${SITE_CONFIG}\n  root * \"${ESCAPED_DOCROOT}\""

    # Compression
    if [ "$COMPRESSION" -eq 1 ]; then
      SITE_CONFIG="${SITE_CONFIG}\n  encode zstd gzip"
    fi

    # Request handling for worker mode
    SITE_CONFIG="${SITE_CONFIG}\n  php_server"

    # Metrics endpoint

    # Enhanced routing for subfolder applications (e.g. /cockpit, /admin)
    SITE_CONFIG="${SITE_CONFIG}\n  # Handle subfolder apps first"
    SITE_CONFIG="${SITE_CONFIG}\n  @subapp {"
    SITE_CONFIG="${SITE_CONFIG}\n    file {"
    SITE_CONFIG="${SITE_CONFIG}\n      try_files {path} {path}/index.php"
    SITE_CONFIG="${SITE_CONFIG}\n    }"
    SITE_CONFIG="${SITE_CONFIG}\n  }"
    SITE_CONFIG="${SITE_CONFIG}\n  rewrite @subapp {http.matchers.file.relative}"
    SITE_CONFIG="${SITE_CONFIG}\n  # Static file serving"
    SITE_CONFIG="${SITE_CONFIG}\n  file_server"

    # Headers for worker mode
    SITE_CONFIG="${SITE_CONFIG}\n  header {\n    X-Powered-By \"FrankenPHP Worker\"\n  }"

    # Logging - always log to file, add console output in verbose mode
    SITE_CONFIG="${SITE_CONFIG}\n  log {"
    SITE_CONFIG="${SITE_CONFIG}\n    output file {\$PHPUP_DIR}/access.log {"
    SITE_CONFIG="${SITE_CONFIG}\n      roll_size 10mb"
    SITE_CONFIG="${SITE_CONFIG}\n      roll_keep 3"
    SITE_CONFIG="${SITE_CONFIG}\n    }"
    SITE_CONFIG="${SITE_CONFIG}\n    format json"
    SITE_CONFIG="${SITE_CONFIG}\n  }"
    if [ "$VERBOSE" -eq 1 ]; then
      SITE_CONFIG="${SITE_CONFIG}\n  log {\n    output stdout\n    format console\n    level DEBUG\n  }"
    fi

    SITE_CONFIG="${SITE_CONFIG}\n}"

  else
    # ====== CLASSIC MODE CADDYFILE ======
    FINAL_CADDYFILE=".phpup/Caddyfile.classic"

    # Configuration is provided inline via php_ini in the generated Caddyfile

    # Build global config for classic mode
    GLOBAL_CONFIG="{"

    # Admin API disabled
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  admin off"

    # HTTPS configuration
    if [ "$HTTPS_MODE" = "off" ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  auto_https off"
    elif [ "$HTTPS_MODE" = "local" ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  local_certs"
    fi

    # FrankenPHP classic mode configuration
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  frankenphp {"

    # Inline PHP configuration for classic mode
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    php_ini {"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      memory_limit 256M"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      max_execution_time 60"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      upload_max_filesize 50M"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      post_max_size 50M"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      max_file_uploads 20"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      session.save_path {\$PHPUP_DIR}/sessions"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      display_errors On"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      error_reporting E_ALL"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      log_errors On"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      error_log {\$PHPUP_DIR}/php_errors.log"
    if [ "$XDEBUG" -eq 1 ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      xdebug.mode debug"
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      xdebug.start_with_request yes"
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      xdebug.client_host 127.0.0.1"
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      xdebug.client_port 9003"
    fi
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    }"

    # Thread configuration for classic mode
    if [ "$PHP_THREADS" != "auto" ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    num_threads ${PHP_THREADS}"
    fi

    # Max threads for classic mode (optional)
    if [ "$PHP_THREADS" = "auto" ]; then
      # Auto-scaling threads for classic mode
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    num_threads 2"
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    max_threads 10"
    fi

    # Max wait time
    if [ "$MAX_WAIT_TIME" != "30s" ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    max_wait_time ${MAX_WAIT_TIME}"
    fi

    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  }"

    # Debug mode
    if [ "$VERBOSE" -eq 1 ]; then
      GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  debug"
    fi

    # Performance settings for classic mode
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  servers {"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    timeouts {"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      read_body 30s"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      read_header 10s"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      write 30s"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n      idle 2m"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n    }"
    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n  }"

    GLOBAL_CONFIG="${GLOBAL_CONFIG}\n}"

    # Build site config for classic mode
    # Escape host and docroot for Caddyfile safety (already validated but defense in depth)
    ESCAPED_HOST=$(printf '%s' "$HOST" | sed 's/"/\\"/g')
    ESCAPED_DOCROOT=$(printf '%s' "$DOCROOT" | sed 's/"/\\"/g')

    # Handle custom domains with proper TLS configuration
    if [ -n "$DOMAIN" ]; then
      ESCAPED_DOMAIN=$(printf '%s' "$DOMAIN" | sed 's/"/\\"/g')
      if [ "$HTTPS_MODE" = "local" ]; then
        # Custom domain with HTTPS - include computed port
        SITE_CONFIG="https://${ESCAPED_DOMAIN}:${PORT} {"
        # Add TLS directive to use mkcert certificates
        SITE_CONFIG="${SITE_CONFIG}\n  tls {\\\$PHPUP_DIR}/certs/${ESCAPED_DOMAIN}.pem {\\\$PHPUP_DIR}/certs/${ESCAPED_DOMAIN}-key.pem"
      elif [ "$HTTPS_MODE" = "off" ]; then
        # Custom domain with HTTP
        SITE_CONFIG="http://${ESCAPED_DOMAIN}:${PORT} {"
      else
        # Custom domain with automatic HTTPS
        SITE_CONFIG="https://${ESCAPED_DOMAIN}:${PORT} {"
      fi
    else
      # No custom domain - use HOST:PORT
      if [ "$HTTPS_MODE" = "off" ]; then
        SITE_CONFIG="http://${ESCAPED_HOST}:${PORT} {"
      else
        SITE_CONFIG="${ESCAPED_HOST}:${PORT} {"
      fi
    fi
    SITE_CONFIG="${SITE_CONFIG}\n  root * \"${ESCAPED_DOCROOT}\""

    # Compression
    if [ "$COMPRESSION" -eq 1 ]; then
      SITE_CONFIG="${SITE_CONFIG}\n  encode zstd gzip"
    fi

    # PHP handling for classic mode
    SITE_CONFIG="${SITE_CONFIG}\n  php_server"

    # Metrics endpoint

    # Enhanced routing: static files ‚Üí subfolder apps ‚Üí directory browsing ‚Üí router fallback

    # Static files (non-PHP) - must come first to avoid conflicts with subfolder routing
    SITE_CONFIG="${SITE_CONFIG}\n  @static {"
    SITE_CONFIG="${SITE_CONFIG}\n    file"
    SITE_CONFIG="${SITE_CONFIG}\n    not path_regexp \\.php$"
    SITE_CONFIG="${SITE_CONFIG}\n    not path /"
    SITE_CONFIG="${SITE_CONFIG}\n  }"
    SITE_CONFIG="${SITE_CONFIG}\n  handle @static {"

    # Static file handling continues...
    SITE_CONFIG="${SITE_CONFIG}\n    file_server"
    SITE_CONFIG="${SITE_CONFIG}\n  }"

    # Generic subfolder app routing - route /subfolder/* to /subfolder/index.php if it exists
    SITE_CONFIG="${SITE_CONFIG}\n  # Generic subfolder application routing"
    SITE_CONFIG="${SITE_CONFIG}\n  @subapp_routes {"
    SITE_CONFIG="${SITE_CONFIG}\n    path_regexp subapp ^/([^/]+)/(.*)$"
    SITE_CONFIG="${SITE_CONFIG}\n    file {re.subapp.1}/index.php"
    SITE_CONFIG="${SITE_CONFIG}\n  }"
    SITE_CONFIG="${SITE_CONFIG}\n  handle @subapp_routes {"
    SITE_CONFIG="${SITE_CONFIG}\n    rewrite * /{re.subapp.1}/index.php?{query}"
    SITE_CONFIG="${SITE_CONFIG}\n  }"




    # Fallback to root index.php for unmatched routes (PHP processing) - must be in handle block
    SITE_CONFIG="${SITE_CONFIG}\n  # Default fallback - must come last"
    SITE_CONFIG="${SITE_CONFIG}\n  handle {"
    SITE_CONFIG="${SITE_CONFIG}\n    try_files {path} /index.php?{query}"
    SITE_CONFIG="${SITE_CONFIG}\n  }"
    SITE_CONFIG="${SITE_CONFIG}\n  header *.{js,css,woff,woff2,ttf} Cache-Control \"public, max-age=604800\""

    # Headers for classic mode
    SITE_CONFIG="${SITE_CONFIG}\n  header {\n    X-Powered-By \"FrankenPHP Classic\"\n  }"

    # Logging - always log to file, add console output in verbose mode
    SITE_CONFIG="${SITE_CONFIG}\n  log {"
    SITE_CONFIG="${SITE_CONFIG}\n    output file {\$PHPUP_DIR}/access.log {"
    SITE_CONFIG="${SITE_CONFIG}\n      roll_size 10mb"
    SITE_CONFIG="${SITE_CONFIG}\n      roll_keep 3"
    SITE_CONFIG="${SITE_CONFIG}\n    }"
    SITE_CONFIG="${SITE_CONFIG}\n    format json"
    SITE_CONFIG="${SITE_CONFIG}\n  }"
    if [ "$VERBOSE" -eq 1 ]; then
      SITE_CONFIG="${SITE_CONFIG}\n  log {\n    output stdout\n    format console\n    level DEBUG\n  }"
    fi

    SITE_CONFIG="${SITE_CONFIG}\n}"
  fi

  # Write the Caddyfile
  if ! echo -e "${GLOBAL_CONFIG}\n\n${SITE_CONFIG}" > "$FINAL_CADDYFILE"; then
    err "Failed to write Caddyfile to $FINAL_CADDYFILE"
    exit 1
  fi
  MODE="generated"

  # Build command
  CMD=(frankenphp)

  # Determine subcommand
  if frankenphp run --help >/dev/null 2>&1; then
    CMD+=("run")
  else
    CMD+=("start")
  fi

  CMD+=("--config" "$FINAL_CADDYFILE")

  # Add extra args if provided
  if [ ${#EXTRA_ARGS[@]} -gt 0 ]; then
    CMD+=("${EXTRA_ARGS[@]}")
  fi

  if [ "$DRY_RUN" -ne 1 ]; then
    if [ "$EFFECTIVE_WORKER_MODE" -eq 1 ]; then
      log "üìÑ Generated worker mode Caddyfile at $FINAL_CADDYFILE"
      log "üöÄ Starting FrankenPHP (worker mode) at ${PROTOCOL}://$HOST:$PORT"
      log "Worker file: $WORKER_FILE"
      log "Worker instances: 2"
    else
      log "üìÑ Generated classic mode Caddyfile at $FINAL_CADDYFILE"
      log "üöÄ Starting FrankenPHP (classic mode) at ${PROTOCOL}://$HOST:$PORT"
    fi
    log "üìÅ Docroot: $DOCROOT"
    if [ "$PHP_THREADS" != "auto" ]; then
      log "PHP threads: $PHP_THREADS"
    elif [ "$EFFECTIVE_WORKER_MODE" -eq 1 ]; then
      log "PHP threads: 4 (optimized for worker mode)"
    else
      log "PHP threads: 2-10 (auto-scaling for classic mode)"
    fi
    if [ "$WATCH_MODE" -eq 1 ]; then
      log "File watcher: enabled"
    fi
    # Using inline php_ini configuration
  fi
fi

if [ "$DRY_RUN" -eq 1 ]; then
  # Build a quoted command preview
  CMD_STR=$(printf '%q ' "${CMD[@]}")
  CMD_STR=${CMD_STR%% }
  echo "DRY-RUN"
  if [ "${EFFECTIVE_WORKER_MODE:-$WORKER_MODE}" -eq 1 ]; then
    echo "Mode: worker (generated)"
  else
    echo "Mode: classic (${MODE:-unknown})"
  fi
  if [ "$MODE" = "caddyfile" ] || [ "$MODE" = "generated" ]; then
    echo "Caddyfile: $FINAL_CADDYFILE"
    if [ "$MODE" = "generated" ] && [ "$VERBOSE" -eq 1 ]; then
      echo "Caddyfile contents:"
      cat "$FINAL_CADDYFILE" | sed 's/^/  /'
    fi
  fi
  echo "URL: ${PROTOCOL}://${HOST}:${PORT}"
  echo "üìÅ Docroot: $DOCROOT"
  echo "ServerName: $SERVER_NAME"
  if [ "${EFFECTIVE_WORKER_MODE:-$WORKER_MODE}" -eq 1 ]; then
    echo "Worker mode: enabled"
    if [ -n "${WORKER_FILE:-}" ]; then
      echo "Worker file: $WORKER_FILE"
    fi
  fi
  if [ "$PHP_THREADS" != "auto" ]; then
    echo "PHP threads: $PHP_THREADS"
  elif [ "${EFFECTIVE_WORKER_MODE:-$WORKER_MODE}" -eq 1 ]; then
    echo "PHP threads: 4 (optimized for worker mode)"
  else
    echo "PHP threads: 2-10 (auto-scaling for classic mode)"
  fi
  if [ "$WATCH_MODE" -eq 1 ]; then
    echo "File watcher: enabled"
  fi
  if [ "$HTTPS_MODE" != "off" ]; then
    echo "HTTPS mode: $HTTPS_MODE"
  fi
  # Using inline php_ini configuration
  echo "Command: $CMD_STR"
  exit 0
fi

# Set up signal handling for graceful shutdown
cleanup() {
  local exit_code=${1:-0}

  if [ -n "$FRANKENPHP_PID" ]; then
    log "‚èπÔ∏è  Shutting down FrankenPHP (PID: $FRANKENPHP_PID)..."

    # Check if process is still running
    if kill -0 "$FRANKENPHP_PID" 2>/dev/null; then
      # Send SIGTERM first for graceful shutdown
      kill -TERM "$FRANKENPHP_PID" 2>/dev/null

      # Wait up to 10 seconds for graceful shutdown
      local count=0
      while [ $count -lt 10 ] && kill -0 "$FRANKENPHP_PID" 2>/dev/null; do
        sleep 1
        count=$((count + 1))
      done

      # Force kill if still running
      if kill -0 "$FRANKENPHP_PID" 2>/dev/null; then
        log "üí• Force killing FrankenPHP (PID: $FRANKENPHP_PID)..."
        kill -KILL "$FRANKENPHP_PID" 2>/dev/null
        sleep 1
      fi
    fi

    # Final verification
    if kill -0 "$FRANKENPHP_PID" 2>/dev/null; then
      log "‚ö†Ô∏è  Warning: FrankenPHP process may still be running (PID: $FRANKENPHP_PID)"
    else
      log "‚úÖ FrankenPHP shutdown complete."
    fi
  fi

  if [ "$HOSTS_ENTRY_ADDED" -eq 1 ] && [ "$MANAGE_HOSTS" -eq 1 ] && [ -n "$DOMAIN" ]; then
    if manage_hosts_entry "remove" "$DOMAIN" "127.0.0.1"; then
      HOSTS_ENTRY_ADDED=0
    else
      log "‚ö†Ô∏è  Failed to remove $DOMAIN from /etc/hosts"
    fi
  fi

  exit "$exit_code"
}

# Enhanced signal handling with better coverage
trap 'cleanup 130' SIGINT   # Ctrl+C
trap 'cleanup 143' SIGTERM  # Termination signal
trap 'cleanup 129' SIGHUP   # Hangup signal

# Validate command before execution
if [ ${#CMD[@]} -eq 0 ]; then
  err "Internal error: empty command array"
  exit 1
fi

# Start FrankenPHP in background to allow signal handling
log "üöÄ Executing: ${CMD[*]}"

# Suppress FrankenPHP output unless debug mode is enabled
if [ "$VERBOSE" -eq 0 ]; then
  "${CMD[@]}" >/dev/null 2>&1 &
else
  "${CMD[@]}" &
fi
FRANKENPHP_PID=$!

# Verify process started successfully with retry
STARTUP_RETRIES=5
STARTUP_DELAY=0.5
for i in $(seq 1 $STARTUP_RETRIES); do
  sleep $STARTUP_DELAY
  if kill -0 "$FRANKENPHP_PID" 2>/dev/null; then
    break
  fi
  if [ "$i" -eq "$STARTUP_RETRIES" ]; then
    err "Failed to start FrankenPHP"

    # Try to get error details
    if [ -f ".phpup/php_errors.log" ]; then
      err "Recent PHP errors:"
      tail -5 ".phpup/php_errors.log" 2>/dev/null | while read -r line; do
        err "  $line"
      done
    fi

    exit 1
  fi
done

log "üßü FrankenPHP started with PID: $FRANKENPHP_PID"
debug "Server should be accessible at: ${PROTOCOL}://$HOST:$PORT"

# Health check with retries (runs always, output only in verbose mode)
if command_exists curl; then
  HEALTH_RETRIES=5
  HEALTH_DELAY=1
  HEALTH_OK=0

  for i in $(seq 1 $HEALTH_RETRIES); do
    sleep $HEALTH_DELAY
    if curl -s -f --connect-timeout 3 "${PROTOCOL}://$HOST:$PORT" >/dev/null 2>&1; then
      HEALTH_OK=1
      break
    fi
    # Check if process died during health check
    if ! kill -0 "$FRANKENPHP_PID" 2>/dev/null; then
      err "FrankenPHP process died unexpectedly"
      if [ -f ".phpup/php_errors.log" ]; then
        err "Recent PHP errors:"
        tail -5 ".phpup/php_errors.log" 2>/dev/null | while read -r line; do
          err "  $line"
        done
      fi
      exit 1
    fi
  done

  if [ "$HEALTH_OK" -eq 1 ]; then
    debug "‚úÖ Server health check passed"
  else
    log "‚ö†Ô∏è  Server health check failed after ${HEALTH_RETRIES} attempts - server might not be ready"
  fi
fi

# Open browser if requested
if [ "$OPEN_BROWSER" -eq 1 ]; then
  open_browser "${PROTOCOL}://$HOST:$PORT"
fi

# Wait for FrankenPHP and handle signals
wait $FRANKENPHP_PID
exit_status=$?

# Clean exit with enhanced error reporting
if [ $exit_status -ne 0 ]; then
  case $exit_status in
    1) log "‚ö†Ô∏è  FrankenPHP exited with error (status: $exit_status)" ;;
    130) log "üõë FrankenPHP interrupted by user (Ctrl+C)" ;;
    143) log "üõë FrankenPHP terminated (SIGTERM)" ;;
    *) log "‚ö†Ô∏è  FrankenPHP exited with status: $exit_status" ;;
  esac

  # Show recent errors if available
  if [ -f ".phpup/php_errors.log" ] && [ "$VERBOSE" -eq 1 ]; then
    if [ -s ".phpup/php_errors.log" ]; then
      log "Recent PHP errors:"
      tail -10 ".phpup/php_errors.log" 2>/dev/null | while read -r line; do
        log "  $line"
      done
    fi
  fi
fi

cleanup $exit_status
